
import React, { useState, useEffect, useCallback } from 'react';
import { BucketListItemType } from './types';
import Header from './components/Header';
import AddItemForm from './components/AddItemForm';
import BucketList from './components/BucketList';
import { supabase } from './lib/supabase';
import type { Session } from '@supabase/supabase-js';
import ShareModal from './components/ShareModal';
import FriendListView from './components/FriendListView';

const getErrorMessage = (error: unknown): string => {
  const fallbackMessage = "An unexpected error occurred. Please check the console.";

  if (error instanceof Error) {
    return error.message || fallbackMessage;
  }
  if (typeof error === 'object' && error !== null && 'message' in error) {
    const msg = (error as { message: unknown }).message;
    if (typeof msg === 'string') {
      return msg || fallbackMessage;
    }
  }
  if (typeof error === 'string') {
    return error || fallbackMessage;
  }
  console.error("Caught an error with an unknown structure:", error);
  return fallbackMessage;
};

interface HomeProps {
  session: Session;
}

const Home: React.FC<HomeProps> = ({ session }) => {
  const [items, setItems] = useState<BucketListItemType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [showShareModal, setShowShareModal] = useState(false);
  const [friendList, setFriendList] = useState<(BucketListItemType & { owner_email: string; })[] | null>(null);
  const [isViewingFriendList, setIsViewingFriendList] = useState(false);


  const fetchItems = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const { data, error: fetchError } = await supabase
        .from('items')
        .select('*')
        .order('created_at', { ascending: true });

      if (fetchError) {
        throw fetchError;
      }
      if (data) {
        setItems(data);
      }
    } catch (err: unknown) {
      const message = getErrorMessage(err);
      let friendlyMessage = `There was an issue fetching your list. Please check the console.`;

      if (message.includes('permission denied')) {
        friendlyMessage = 'Could not fetch your list. Please ensure you have run the latest SQL script from the Home.tsx comments to set up Row Level Security.';
      } else if (message.toLowerCase().includes('failed to fetch') || message.toLowerCase().includes('networkerror')) {
        friendlyMessage = 'Could not connect to the database. Please check your internet connection.';
      }
      
      setError(friendlyMessage);
      console.error("Error fetching items:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    /**
     * !! IMPORTANT !!
     * Run this script in your Supabase SQL Editor to enable the "Share with Friends" feature.
     * This adds a table for share keys and a secure function to fetch a list by its key.
     *
     * -- 1. Create a table to store share keys
     * create table public.share_keys (
     *   id bigint generated by default as identity primary key,
     *   created_at timestamp with time zone not null default now(),
     *   user_id uuid not null references auth.users(id) on delete cascade unique,
     *   share_key uuid not null default gen_random_uuid() unique
     * );
     *
     * -- 2. Enable Row Level Security on the new table
     * alter table public.share_keys enable row level security;
     *
     * -- 3. Create policies for users to manage their OWN key
     * create policy "Users can view their own share key." on public.share_keys
     *   for select using (auth.uid() = user_id);
     *
     * create policy "Users can create their own share key." on public.share_keys
     *   for insert with check (auth.uid() = user_id);
     *
     * create policy "Users can delete their own share key." on public.share_keys
     *   for delete using (auth.uid() = user_id);
     *
     * -- 4. Create a secure function to get a list by a share key
     * create or replace function public.get_list_by_key(key_to_check uuid)
     * returns table (
     *   id bigint,
     *   created_at timestamp with time zone,
     *   text text,
     *   completed boolean,
     *   user_id uuid,
     *   owner_email text
     * ) as $$
     * begin
     *   return query
     *   select i.id, i.created_at, i.text, i.completed, i.user_id, u.email as owner_email
     *   from public.items i
     *   join public.share_keys sk on i.user_id = sk.user_id
     *   join auth.users u on i.user_id = u.id
     *   where sk.share_key = key_to_check;
     * end;
     * $$ language plpgsql security definer;
     *
     * -- Note: The original RLS policies for the 'items' table are still in effect
     * -- and prevent direct access. This function provides a secure read-only gateway.
     */
    if (!isViewingFriendList) {
        fetchItems();
    }
  }, [fetchItems, isViewingFriendList]);

  const handleAddItem = useCallback(async (text: string) => {
    if (text.trim() === '' || !session.user) return;
    setError(null);
    try {
      const newItem: Omit<BucketListItemType, 'id' | 'created_at'> = {
        text,
        completed: false,
        user_id: session.user.id,
      };

      const { data, error } = await supabase
        .from('items')
        .insert([newItem])
        .select()
        .single();

      if (error) throw error;
      if (data) {
         setItems(prevItems => [...prevItems, data]);
      }
    } catch (err: unknown) {
       setError(getErrorMessage(err));
       console.error("Error adding item:", err);
    }
  }, [session.user]);

  const handleToggleComplete = useCallback(async (id: number, currentStatus: boolean) => {
    setError(null);
    setItems(prevItems =>
      prevItems.map(item =>
        item.id === id ? { ...item, completed: !item.completed } : item
      )
    );
    try {
       const { error } = await supabase
        .from('items')
        .update({ completed: !currentStatus })
        .eq('id', id);

      if (error) throw error;
    } catch (err: unknown) {
       setError(getErrorMessage(err));
       console.error("Error updating item:", err);
       setItems(prevItems =>
          prevItems.map(item =>
            item.id === id ? { ...item, completed: currentStatus } : item
          )
        );
    }
  }, []);

  const handleDeleteItem = useCallback(async (id: number) => {
    setError(null);
    const previousItems = items;
    setItems(prevItems => prevItems.filter(item => item.id !== id));
    try {
      const { error } = await supabase
        .from('items')
        .delete()
        .eq('id', id);

      if (error) throw error;
    } catch(err: unknown) {
       setError(getErrorMessage(err));
       console.error("Error deleting item:", err);
       setItems(previousItems);
    }
  }, [items]);
  
  const handleViewFriendList = async (key: string) => {
    if (!key.trim()) {
      setError("Please enter a friend's key.");
      return;
    }
    setLoading(true);
    setError(null);
    setShowShareModal(false);

    try {
      const { data, error: rpcError } = await supabase.rpc('get_list_by_key', { key_to_check: key });
      if (rpcError) throw rpcError;
      
      if (!data || data.length === 0) {
        throw new Error("Invalid or expired key. No list found for this key.");
      }
      
      setFriendList(data);
      setIsViewingFriendList(true);
    } catch (err: unknown) {
      setError(getErrorMessage(err));
      console.error("Error fetching friend list:", err);
    } finally {
      setLoading(false);
    }
  };

  const switchToMyList = () => {
    setIsViewingFriendList(false);
    setFriendList(null);
    fetchItems();
  };

  const handleSignOut = async () => {
    await supabase.auth.signOut();
  };

  return (
    <>
      <Header userEmail={session.user.email} onSignOut={handleSignOut} />
      <main>
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4" role="alert">
            <strong className="font-bold">Error: </strong>
            <span className="block sm:inline ml-2">{error}</span>
          </div>
        )}

        {isViewingFriendList && friendList ? (
          <FriendListView items={friendList} onBack={switchToMyList} />
        ) : (
          <>
            <div className="flex flex-col sm:flex-row gap-4 items-center mb-8">
              <div className="flex-grow w-full">
                <AddItemForm onAddItem={handleAddItem} />
              </div>
              <button
                onClick={() => setShowShareModal(true)}
                className="w-full sm:w-auto flex-shrink-0 bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-700 text-slate-700 dark:text-slate-200 font-bold py-3 px-6 rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 dark:focus:ring-offset-slate-900 transition-all duration-300 transform hover:scale-105"
              >
                <i className="fas fa-user-friends mr-2"></i>
                Share & View
              </button>
            </div>
            
            {loading ? (
              <div className="text-center p-10">
                 <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-500 mx-auto"></div>
                 <p className="mt-4 text-slate-500 dark:text-slate-400">Loading your dreams...</p>
              </div>
            ) : (
              <BucketList
                items={items}
                onToggleComplete={handleToggleComplete}
                onDeleteItem={handleDeleteItem}
              />
            )}
          </>
        )}
      </main>
      
      {showShareModal && (
        <ShareModal
          userId={session.user.id}
          onClose={() => setShowShareModal(false)}
          onViewFriendList={handleViewFriendList}
        />
      )}
    </>
  );
};

export default Home;
